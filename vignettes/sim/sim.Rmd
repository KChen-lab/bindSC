---
title: "Integration of mulitOmic data using simulation dataset"
author: "Jinzhuang Dou @ Kenchen'lab (MDACC)"
date: "March 1, 2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```

This guide will demonstrate the usage of bindSC to align scRNA-seq and protein data. The test dataset is from bone marrow (BM) samples measured using the CITE-seq technology(Stuart et al., Cell 2019 [https://www.cell.com/cell/fulltext/S0092-8674(19)30559-8]).

#### Stage 1: Load the scRNA-seq and protein data
Remove cells that have no variation in initilized gene score matrix Z

```{r load data, message = FALSE, warning=FALSE, results='hide'}
library(bindSC)
source("../../reviewers_response/method_eval/Eval.R")
source("../../reviewers_response/method_eval/runMethod.R")
library(peakRAM)
noise <- 0.5
popSize <- 12
dt <- readRDS(file="./sim3_0.5pop12.RDS")
summary(dt)
dim(dt$X)
dim(dt$Y)
dim(dt$Z0)

N <- ncol(dt$X)
y <- dt$Y
x <- dt$X
z0 <- dt$Z0
dim(x)
dim(y)
dim(z0)

```

#### Stage 2: Parameter optimization [optional]  

There are two key parameters that may influence the integraton results: 1) `lambda` the modality weighting factor; 2) `alpha` the weighting factor of initilized gene score matrix. The `parameter optimization` step will run bindS alignment with `0<lambda<1` and `0<alpha<1`. This may take a long time if the cell number is large. You can use use the downsampling procedure to run this step. We found that the defualt settings with lambda = 0.5 and alpha = 0.5 work well on most integration tasks. The `parameter optimization` step could be skipped if you want to use the default settings. 

To run the `parameter optimization` step, you need to prepare for the cluster annotaions for each dataset. 

This guide will show the perfomance of methods (bindSC, Seurat, LIGER, and Harmony) on the simulaiton dataset

#### Stage 1: load simulation datasets

```{r cars, message = FALSE, warning=FALSE, results='hide'}

x.clst <- dt$x.clst
y.clst <- dt$y.clst

X <- z0
Z0 <-  x
X <- x
Z0 <- z0

celltype <- c(as.character(x.clst), as.character(y.clst))


rd_time <- c()
rd_mem <- c()

```
#### Stage 2: run four methods
Run bindSC. The time used is also shown.
```{r runbindsc,  message = FALSE, warning=FALSE, results='hide'}
source("../../bindsc/BiCCA.R")
source("../../bindsc/generics.R")
source("../../reviewers_response/method_eval/Eval.R")
source("../../reviewers_response/method_eval/runMethod.R")

K <- 15
out <- peakRAM(
  bindsc <- BiCCA( X = x,
             Y = y, 
             Z0 =z0, 
             X.clst = x.clst,
             Y.clst = y.clst,
             alpha = 0, 
             lambda = 0.5,
             K = K,
             temp.path  = "out",
             num.iteration = 50,
             tolerance = 0.0001,
             save = TRUE,
             parameter.optimize = FALSE,
             block.size = 1000)

)


rd_mem <- c(rd_mem, out$Peak_RAM_Used_MiB)
rd_time <- c(rd_time, out$Elapsed_Time_sec)
bindsc_umap <- get_UMAP(rbind(bindsc$u, bindsc$r))

```
Run Seurat. The time used is also shown.
```{r runSeurat,message = FALSE, warning=FALSE, results='hide'}


out<-peakRAM(seurat <- runSeurat(X = X, Z0=Z0, K = K))


rd_mem <- c(rd_mem, out$Peak_RAM_Used_MiB)
rd_time <- c(rd_time, out$Elapsed_Time_sec)

seurat_umap <- get_UMAP(seurat)
```
Run LIGER. The time used is also shown.
```{r runLIGER,message = FALSE, warning=FALSE, results='hide'}

out<-peakRAM(liger <- runLIGER(X = X, Z0=Z0, K = K))


rd_mem <- c(rd_mem, out$Peak_RAM_Used_MiB)
rd_time <- c(rd_time, out$Elapsed_Time_sec)

liger_umap <- get_UMAP(liger)
```
Run Harmony. The time used is also shown.
```{r runHarmony,message = FALSE, warning=FALSE, results='hide'}

out<-peakRAM(harmony <- runHarmony(X = X, Z0=Z0, K = K))



rd_mem <- c(rd_mem, out$Peak_RAM_Used_MiB)
rd_time <- c(rd_time, out$Elapsed_Time_sec)

harmony_umap <- get_UMAP(harmony)
```

### Load data for other methods

```{r, load other manifold-alignment based method}
#noise <- c(02)
noise <- 0.9
dt <- readRDS(file=paste0("./sim3_",noise,".RDS"))
celltype <- c(dt$x.clst, dt$y.clst)
library(umap)
othermethod <- c("scot","pamona","unioncom","mmdma")
rd <-c()
for(m in othermethod){
  for(l in c(noise)){ 
      #input_file <- paste0("./otherMethods/sim3-",l,"pop12-",m,"-rna.csv")
      input_file <- paste0("./otherMethods/sim3-",l,"-",m,"-rna.csv")
      if (!file.exists(input_file)){
        a <- data.frame("UMAP1"=c(0,0),
                        "UMAP2"=c(0,0),
                        "celltype"=c("NA","NA"),
                        "tech"=c("A","B"),
                        "method"=c(m,m))
        
      }
      else{
        #rna <- read.csv(file=paste0("./otherMethods/sim3-",l,"pop12-",m,"-rna.csv"))
        #atac <- read.csv(file=paste0("./otherMethods/sim3-",l,"pop12-",m,"-atac.csv"))
        rna <- read.csv(file=paste0("./otherMethods/sim3-",l,"-",m,"-rna.csv"))
        atac <-read.csv(file=paste0("./otherMethods/sim3-",l,"-",m,"-atac.csv"))
        
        colnames(atac) <- colnames(rna)
        plt_dt <- rbind(rna,atac)
        plt_dt <- plt_dt[,-1]
        a <- umap(plt_dt)
        a <- data.frame("UMAP1"=a$layout[,1],
                        "UMAP2"=a$layout[,2],
                        "celltype"=celltype,
                        "tech"=c(rep("A", length(dt$x.clst)), rep("B", length(dt$y.clst))),
                        "method"=rep(m, nrow(plt_dt))
                        )
      }
      rd <- rbind(rd,a)
  }
}
rd$celltype<- rep(celltype,4)
#rd$celltype<-c("NA","NA",rep(celltype,3))

```





#### Stage 3: Visulization of integration for each method. 
UMAP shows results from co-embeddings of each method, split by different modalites. For convenience, the cells are colored by 
annotation from co-assyed profiles. This means that the color is consistent between two modalites

```{r, plot_uma, message = FALSE, warning=FALSE, results='hide',fig.height=6, fig.width=12}
#source("./Eval.R")
tp <- readRDS(file=paste0("umap_out_",noise,".RDS"))
tp <- tp[tp$method%in%c("bindSC","Seurat","LIGER","Harmony"),]
cell_size <- nrow(tp[tp$tech=="A" & tp$method=="bindSC",])
merged_dt <- data.frame("UMAP1"=tp[,1], "UMAP2"=tp[,2], 
                        "celltype"=rep(as.factor(celltype),4), 
                        tech=rep(c(rep("A",cell_size), rep("B",cell_size)),4),
                        "method"=c(rep("bindSC", cell_size*2),  
                                   rep("Seurat", cell_size*2),
                                   rep("LIGER",  cell_size*2),
                                   rep("Harmony", cell_size*2)))

a <- merged_dt

merged_dt<-rbind(merged_dt,rd)
merged_dt$method<-as.character(merged_dt$method)
merged_dt$method[merged_dt$method=="scot"]<-"SCOT"
merged_dt$method[merged_dt$method=="pamona"]<-"Pamona"
merged_dt$method[merged_dt$method=="unioncom"]<-"UnionCom"
merged_dt$method[merged_dt$method=="mmdma"]<-"MMD-MA"
saveRDS(merged_dt,file=paste0("umap_out_",noise,".RDS"))
p <- umapPlot_all(merged_dt = merged_dt, tech_label = c("scRNA-seq","scATAC-seq"))

tiff(paste0("sim","_", noise,"_","12.tiff"), width=12, height =4, res =300, units = "in", compression = "lzw")
print(p)
dev.off()  
p

```

p

#### Stage 4: Visulization of integration accuracy. 
We use three indexs: 1) silhouette score; 2) alignment mixing score; 3) anchoring distance. 
Higher silhoouette score means cell type are well separated indim the co-embedding space. 
Higher alignment mixing score means two modalites are aligned well in the co-embedding space.
Lower Anchoring distance means the cell with measurement from two modalites is closer in the co-embedding space.

```{r, plot_alignment accuracy, message = FALSE, warning=FALSE, results='hide',fig.height=4, fig.width=9}

p

```

#### Stage 5: Running time and memory usage 
```{r, plot_alignment accuracy, message = FALSE, warning=FALSE, results='hide',fig.height=4, fig.width=4}
# Use Gb

cpu_time <- data.frame("Time"=rd_time,"Memory"=rd_mem,"Method"=c("bindSC","Seurat","LIGER","Harmony"))
cpu_time$Memory <- cpu_time$Memory/1024
p <- ggscatter(cpu_time,x="Time", y="Memory", color="Method",label="Method", repel = TRUE)  + 
  theme_classic() + NoLegend() + xlim(0, max(cpu_time$Time))+ 
  xlab("Elapsed time (Sec)") + ylab("Maximum memory usage (Gb)") + ggtitle(paste0("Cell size (", length(x.clst),",", length(y.clst),")" ))
p
saveRDS(cpu_time,file="./simu.cpu_usage.RDS")


tiff(paste0("sim","_", noise,"_", popSize,".time.tiff"), width=4, height =4, res =300, units = "in", compression = "lzw")
print(p)
dev.off()  

```


#### Stage 6: Save resutls

```{r save results}
result <- list()
result$coembed <- coembed
result$umap <- merged_dt
result$score <- out
saveRDS(result, file="simu.methodEval.RDS")
```

### Stage 7: Explore integration results on rare cell type

```{r load data}

# plot bindSC only 

i <- "LIGER"
#i <- "Harmony"
#i <- "Seurat"
i <- "Pamona"
x_pos <- which(merged_dt$method==i & merged_dt$tech=="A")
y_pos <- which(merged_dt$method==i & merged_dt$tech=="B")
cell_type_predict<-label_transfer(dt1 = coembed[x_pos,],
               X.clst = merged_dt$celltype[x_pos],
               dt2 = coembed[y_pos,])
cell_type_true <- merged_dt$celltype[y_pos]
lst <- data.frame("TRUE"=cell_type_true,"Predict"=cell_type_predict$celltype)
confus_mat <- as.matrix(table(lst))
for(j in seq(1,ncol(confus_mat),1)){
  confus_mat[,j] <- confus_mat[,j]/sum(confus_mat[,j])
}



tiff(paste0(i,"label_transfer.tiff",sep=""), width=5, height =5, res =300, units = "in", compression = "lzw")
corrplot(confus_mat,is.corr = FALSE)
dev.off()


```

```{r save results }
sessionInfo()
```